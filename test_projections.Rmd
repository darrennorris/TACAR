---
title: "Test projections"
author: "Darren Norris"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## To do

 - Choose models for scenarios
 - Run scenarios across points
 - Determine Green Status
 - Evaluate uncertainty/sensitivity


## Packages
```{r load-packages, warning=FALSE, message=FALSE}
library(plyr)
library(tidyverse)
library(popdemo)
library(popbio)
library(Rcompadre)
library(Rage)
```

Load functions.
```{r load-functions}
source('R/pop01_param_poun.R')
source('R/pop03_doproj.R')
source('R/pop03_doproj_stoch.R')
```

## Projections
### Population projection parameters. 

Each row holds a unique set of parameters for a matrix population model.
This reflects diverse recovery (conservation action) and extinction (threat) scenarios.

```{r projection-params}
dt <- pop01_param_poun()
```

The first few rows should look like this....
```{r show-parameters, echo=FALSE, warning=FALSE, message=FALSE}
mydigits <- c(NA, NA, 1, 0, 0, 0, 2, 2, 2, 0, 0, 0, 2, 2, 0, 0 ,0, 2, 2, NA)
slice_head(dt, n = 3)  |> 
  kableExtra::kbl(digits = mydigits) |>
  kableExtra::kable_styling(full_width = F,  latex_options = "hold_position")
```

Each row can be easily converted for use in a stage-based matrix population model. 
The following code shows how the first row becomes a stage-based matrix.
```{r mpm-example}
stage_names <- c("a1", "a2", "a3", "a4",
                   "b1", "b2", "b3", "b4",
                   "c1", "c2", "c3", "c4",
                   "d1", "d2", "d3", "d4")
vpop <- unlist(dt[3 , stage_names])
pop_mat <- matrix(vpop, byrow = TRUE, ncol=4)
dimnames(pop_mat) <- list(c("a", "b", "c", "d"),
                            c( "a", "b", "c", "d"))

```

The matrix should look like this:
```{r print-matrix, echo=FALSE}

knitr::kable(format(pop_mat, scientific=F), digits = 4) |> 
  kableExtra::column_spec(1, bold = TRUE) |>
  kableExtra::kable_styling(full_width = F,  latex_options = "hold_position")
```


This matrix includes information of population growth and survival and reproduction.

See https://cran.r-project.org/web/packages/Rage/vignettes/a01_GettingStarted.html

We can show the different matrix components converting to the structure recommended by ...
```{r rcompadre-example, warning=FALSE, message=FALSE}
meta <- data.frame(idNum = 3, 
                   SpeciesAccepted = dt[3 , 'species'],
                   type = dt[3 , 'type'], 
                   first_year = dt[3 , 'first_year']) 
stageInfo <- list(
  data.frame(
    MatrixClassOrganized = rep("active", 4),
    MatrixClassAuthor = c("eggs/hatchling", "juvenile-early", "juvenile-late", "adult")
  ))
# Simple full A matrix
l_pop_mat <- list(mpm = pop_mat)
x <- cdb_build_cdb(mat_a = l_pop_mat, metadata = meta, stages = stageInfo)

# Seperate into U, F, C
mat_u1 <- rbind(
  c(dt[3, 'a1'], dt[3, 'a2'], dt[3, 'a3'], 0),
  c(dt[3, 'b1'], dt[3, 'b2'], dt[3, 'b3'], dt[3, 'b4']),
  c(dt[3, 'c1'], dt[3, 'c2'], dt[3, 'c3'], dt[3, 'c4']),
  c(dt[3, 'd1'], dt[3, 'd2'], dt[3, 'd3'], dt[3, 'd4'])
)
mat_f1 <- rbind(
  c(0.0, 0.0, 0.0, dt[3, 'a4']),
  c(0.0, 0.0, 0.0, 0.0),
  c(0.0, 0.0, 0.0, 0.0), 
  c(0.0, 0.0, 0.0, 0.0)
)
mat_c1 <- rbind(
  c(0.0, 0.0, 0.0, 0.0),
  c(0.0, 0.0, 0.0, 0.0),
  c(0.0, 0.0, 0.0, 0.0), 
  c(0.0, 0.0, 0.0, 0.0)
)
l_u <- list(m_u = mat_u1)
l_f <- list(m_f = mat_f1)
l_c <- list(m_c = mat_c1)

my_comadre <- cdb_build_cdb(
  mat_u = l_u, mat_f = l_f, mat_c = l_c,
  metadata = meta, 
  stages = stageInfo
)

matA(my_comadre)
matA(x)
matU(my_comadre)
matF(my_comadre)
matC(my_comadre)

```

We can get life history metrics
```{r gen-time}
# the time required for a population to 
# increase by a factor of R0 (the net reproductive rate)
gen_time(matU = matU(my_comadre)[[1]], matF(my_comadre)[[1]]) # 17.15
# the average parent-offspring age difference # 16.22
gen_time(matU = matU(my_comadre)[[1]], matF(my_comadre)[[1]], method = "age_diff")
# expected age at reproduction for a cohort 5.69
Rage::gen_time(matU = matU(my_comadre)[[1]], matF(my_comadre)[[1]], method = "cohort")

Rage::life_expect_mean(matU = matU(my_comadre)[[1]], start = 1)
sum(Rage::life_expect_mean(matU(my_comadre)[[1]], start = NULL))
```
Plot the life cycle diagram.
```{r plot-lifecycle}
plot_life_cycle(matA = matA(my_comadre)[[1]], 
                stages = c("eggs/hatchling", "juvenile-early", "juvenile-late", "adult"))
```



### Projection models.

#### Deterministic models

```{r projection-determ, eval=FALSE}
nf <- 10
dt$adultF_n <- nf
# project
dout <- plyr::ddply(dt, 
                    c("species", "type", "first_year","akey"), .fun =  pop03_doproj)
dout$arun <- 1

# Model summaries
model_sum <- dout |> 
  group_by(species, type, first_year, lambda, 
           gen_time, gen_age_diff, life_exp, life_exp_adult, mat_prob, eggs_to_adult) |> 
  summarise(fem_t0 = max(fem_t0), 
            fem_min = min(fem),
              fem_max = max(fem)) |> 
  ungroup()
lambda_n <- length(unique(model_sum$lambda)) # 50
lambda_mean <- mean(model_sum$lambda) # 0.9432
lambda_sd <- sd(model_sum$lambda) # 0.1506
lambda_min <- min(model_sum$lambda) # 0.4659
lambda_max <- max(model_sum$lambda) # 1.1539

# Export for future use
saveRDS(dout, "inst/other/dout.rds")

```

#### Eggs to adult
Using survival values from base model.
```{r eggs-adult}
# The probability of reaching reproductive maturity before death for an egg. 
# Expressed as proportion (0 - 1)
# # 0.008000029 # 0.8%
mp_poun <- mature_prob(matU = matU(my_comadre)[[1]], matR = matF(my_comadre)[[1]])

# To produce one reproductive adult need 125 eggs.
1/mp_poun # 125
# 7 years for a female to lay sufficient eggs 
ceiling(125 / 20)

t0 <- 1000 # number of eggs
n_t1 <- t0 * 0.2       # 200
n_t2 <- n_t1 * 0.333333 # 66.6
n_t3 <- n_t2 * 0.333333 # 22.2
n_t4 <- n_t3 * 0.285714 #  6.3
n_t5 <- n_t4 * 0.285714 #  1.8
n_t6 <- n_t5 * 0.93     #  1.6
n_t7 <- n_t6 * 0.93     #  1.5
n_t8 <- n_t7 * 0.93     #  1.4
n_t9 <- n_t8 * 0.93     #  1.3
ceiling(t0 / n_t5) # 552 eggs to produce one adult (maturity 5 years)
ceiling(t0 / n_t6) # 593 eggs to produce one adult (maturity 6 years)
ceiling(t0 / n_t7) # 638 eggs to produce one adult (maturity 7 years)
ceiling(t0 / n_t8) # 686 eggs to produce one adult (maturity 8 years)
ceiling(t0 / n_t9) # 737 eggs to produce one adult (maturity 9 years)
ceiling(552 / 20) # 28 years for a female to lay sufficient eggs (maturity 5 years)
ceiling(737 / 20) # 37 years for a female to lay sufficient eggs (maturity 9 years)
```



#### Stochastic models

```{r projection-stoch, eval=FALSE}
# Stochastic
#data frame with runs for processing
#nruns <- 100 # 100 gives same pattern as 50
nruns <- 50
dt_stoch <- dt[rep(seq_len(nrow(dt)), nruns), ]
dt_stoch$arun <- rep(1:nruns, each = nrow(dt))
# Approx 30 minutes. 1,212,000 rows. Projections quick. Summaries slow.
# 10:57 - 12:40
dout_stoch <- plyr::ddply(dt_stoch, 
                    c("arun", "species", "type", "first_year","akey"), 
                    .fun =  pop03_doproj_stoch)
table(dout_stoch$model)
table(dout_stoch$type)
model_sum_stoch <- dout_stoch |> 
  group_by(species, type, model, first_year, lambda, lambda_q75,
           gen_time, gen_age_diff_med, gen_age_q75, 
           life_exp_med, life_exp_adult_med, mat_prob_med, mat_prob_q75, 
           eggs_to_adult_med, eggs_to_adult_q75) |> 
  summarise(acount = n(), 
            fem_t0 = max(fem_t0), 
            fem_min = min(fem),
              fem_max = max(fem)) |> 
  ungroup()
# Export for future use
saveRDS(dout_stoch, "inst/other/dout_stoch.rds")
```

#### Combine results.
```{r projection-join, eval=FALSE}
dout <- readRDS("inst/other/dout.rds")
dout_stoch <- readRDS("inst/other/dout_stoch.rds")
# Combine data for plotting
dout_all <- dplyr::bind_rows(dout |> dplyr::select(arun, model, type, first_year, 
                                                   akey, ayear, 
                                                   lambda, gen_time,
                                            fem, fem_t0, fem_diff, change50_flag, 
                                            change30_flag,
                                            double_flag) |> 
                               dplyr::mutate(lambda_lcl = NA, lambda_ucl = NA, 
                                             lambda_sd = NA,  gen_sd = NA), 
                             dout_stoch |> dplyr::select(arun, model, type, first_year, 
                                                         akey, ayear, 
                                                         lambda, lambda_lcl, lambda_ucl, 
                                                         lambda_sd, gen_time, gen_sd,
                                            fem, fem_t0, fem_diff, change50_flag, 
                                            change30_flag,
                                            double_flag))
# Limit adult female number to maximum (20% above original for baseline).
ceiling_threshold <- nf + (nf * 0.2)
dout_all[which(dout_all$fem > ceiling_threshold), 'fem' ] <- ceiling_threshold
# Factors in right order
dout_all$modelf <- 1
dout_all[which(dout_all$model=="Stochastic uniform") , 'modelf'] <- 2
dout_all[which(dout_all$model=="Stochastic equal") , 'modelf'] <- 3
dout_all[which(dout_all$model=="Stochastic bad x2") , 'modelf'] <- 4
dout_all[which(dout_all$model=="Stochastic bad x4") , 'modelf'] <- 5
dout_all$modelf <- as.factor(dout_all$modelf)
levels(dout_all$modelf) <- c("Deterministic", "Stochastic uniform", 
                          "Stochastic equal", "Stochastic bad x2", 
                          "Stochastic bad x4")
unique(dout_all$modelf)
table(dout_all$modelf)
dout_all$typef <- 1
dout_all[which(dout_all$type=="female-hunt 2.5%") , 'typef'] <- 2
dout_all[which(dout_all$type=="female-hunt 5%") , 'typef'] <- 3
dout_all[which(dout_all$type=="female-hunt 10%") , 'typef'] <- 4
dout_all[which(dout_all$type=="female-hunt 25%") , 'typef'] <- 5
dout_all[which(dout_all$type=="female-hunt 50%") , 'typef'] <- 6
dout_all$typef <- as.factor(dout_all$typef)
levels(dout_all$typef) <- c("base", "female-hunt 2.5%", 
                            "female-hunt 5%",
                          "female-hunt 10%", "female-hunt 25%", 
                          "female-hunt 50%")
table(dout_all$typef)
# first year survival
dout_all$first_yearf <- as.factor(dout_all$first_year)
fylev <- paste("first-year\nsurvival\n", seq(0, 0.9, by = 0.1), sep = "")
levels(dout_all$first_yearf) <- fylev
# Export for future use. 17/6/2024 - 1,218,060 rows 21 columns.
saveRDS(dout_all, "inst/other/dout_all.rds")

```

Model summaries.

- RedList guidelines p38    
For example, upper and lower quartiles of the projected magnitude of 
the future reduction (i.e., reductions with 25% and 75% probability) 
may be considered to represent a plausible range of projected reduction

- Green Status Presence    
Present when population is at least 1 as measured by lower quartile population.

- Green Status Viability    
Viable when not declining: lower quartile of lambda >= 1. 
A species is considered viable in a spatial unit if application of 
the Regional Red List Guidelines to the population in the spatial unit 
would result in a categorization of ‘Least Concern’ OR 
‘Near Threatened and Not Declining’.

- Green Status Functional    
Functional when population lower quartile is 10 times base level.
```{r model-summaries, warning=FALSE, message=FALSE, eval=FALSE}
# load data
dout_all <- readRDS("inst/other/dout_all.rds")

# Make unique model ID. boot mean is same as mean (at least to 6 decimal places)
# 300 projection models.
model_ref <- dout_all |>
  group_by(akey, modelf, typef, first_year, arun) |> 
  summarise(lambda = min(lambda), 
            gen_time = min(gen_time),
            yc = length(unique(ayear))) |> 
  ungroup() |> 
  group_by(akey, modelf, typef, first_year) |>
  summarise(count_runs = length(unique(arun)), 
            count_years = min(yc),
            lambda_mean = mean(lambda), 
            lambda_min = min(lambda), 
            lambda_max = max(lambda), 
            lambda_sd = sd(lambda),
            lambda_boot_lcl = Hmisc::smean.cl.boot(lambda)["Lower"],
            lambda_boot_ucl = Hmisc::smean.cl.boot(lambda)["Upper"], 
            lambda_q25 = quantile(lambda, probs = 0.25, na.rm = TRUE),
            lambda_q75 = quantile(lambda, probs = 0.75, na.rm = TRUE), 
            gen_mean = mean(gen_time), 
            gen_min = min(gen_time), 
            gen_max = max(gen_time), 
            gen_sd = sd(gen_time),
            gen_boot_lcl = Hmisc::smean.cl.boot(gen_time)["Lower"],
            gen_boot_ucl = Hmisc::smean.cl.boot(gen_time)["Upper"], 
            gen_q25 = quantile(gen_time, probs = 0.25, na.rm = TRUE),
            gen_q75 = quantile(gen_time, probs = 0.75, na.rm = TRUE),
            ) |> 
  ungroup() |> 
  arrange(typef, first_year, modelf) |>
  mutate(modelid = paste(akey, as.numeric(modelf), sep = "_"), 
         modelkey = row_number()) |> 
  relocate(modelkey, modelid)

# Estimates of generation time
gen_mean <- model_ref |> 
  filter(lambda_mean >= 1, first_year < 0.5) |> pull(gen_mean) |> mean()
gen_q25 <- model_ref |> 
  filter(lambda_mean >= 1, first_year < 0.5) |> pull(gen_mean) |> 
  quantile(probs = 0.25)
gen_q75 <- model_ref |> 
  filter(lambda_mean >= 1, first_year < 0.5) |> pull(gen_mean) |> 
  quantile(probs = 0.75)
gen_3 <- gen_mean * 3
gen_3_q25 <- gen_q25 * 3
gen_3_q75 <- gen_q75 * 3

# Add population changes.
model_ref2 <- model_ref |> left_join(dout_all |>
  filter(ayear %in% c(ceiling(gen_3), ceiling(gen_3_q25), ceiling(gen_3_q75), 100)) |> 
  group_by(akey, modelf, typef, first_year, ayear, arun) |> 
  summarise(fem_t0 = mean(fem_t0), 
            femnew = mean(fem),
            femnew_diff = mean(fem_diff)
  ) |> 
    ungroup() |> 
  group_by(akey, modelf, typef, first_year, ayear) |> 
  summarise(fem_t0 = mean(fem_t0), 
            fem = mean(femnew),
            fem_sd = sd(femnew, na.rm = TRUE), 
            fem_q25 = quantile(femnew, probs = 0.25, na.rm = TRUE),
            fem_q75 = quantile(femnew, probs = 0.75, na.rm = TRUE),
            fem_diff = mean(femnew_diff), 
            fem_diff_sd = sd(femnew_diff, na.rm = TRUE), 
            fem_diff_q25 = quantile(femnew_diff, probs = 0.25, na.rm = TRUE),
            fem_diff_q75 = quantile(femnew_diff, probs = 0.75, na.rm = TRUE)) |> 
  ungroup() |> 
    mutate(ayear = paste("t", ayear, sep="")) |>
  pivot_wider(names_from = ayear, 
               values_from = c(fem, fem_sd, fem_q25, fem_q75, fem_diff, 
                               fem_diff_sd, fem_diff_q25, fem_diff_q75)) |> 
  arrange(typef, first_year, modelf)
)

# Add time to change by 50% and 30% 
model_ref3 <- model_ref2 |> 
  left_join(dout_all |> 
  filter(change50_flag == 1) |>
 group_by(akey, modelf, typef, first_year, arun, 
          change50_flag) |>
  summarise(acount = n(), 
            change50_yf = min(ayear), 
            change50_yl = max(ayear)) |> 
  ungroup() |> 
  group_by(akey, modelf, typef, first_year) |> 
  summarise(change50_ymean = floor(mean(change50_yf)), 
            change50_ysd = sd(change50_yf), 
            change50_yq25 = floor(quantile(change50_yf, probs = 0.25, na.rm = TRUE)),
            change50_yq75 = floor(quantile(change50_yf, probs = 0.75, na.rm = TRUE))) |> 
   ungroup()
) |> left_join(dout_all |> 
  filter(change30_flag == 1) |>
 group_by(akey, modelf, typef, first_year, arun, 
          change30_flag) |>
  summarise(acount = n(), 
            change30_yf = min(ayear), 
            change30_yl = max(ayear)) |> 
  ungroup() |> 
  group_by(akey, modelf, typef, first_year) |> 
  summarise(change30_ymean = floor(mean(change30_yf)), 
            change30_ysd = sd(change30_yf), 
            change30_yq25 = floor(quantile(change30_yf, probs = 0.25, na.rm = TRUE)),
            change30_yq75 = floor(quantile(change30_yf, probs = 0.75, na.rm = TRUE))) |> 
   ungroup()
)

# Export for future use
saveRDS(model_ref3, "inst/other/model_lookup.rds") 
write.csv2(model_ref3, "inst/other/model_lookup.csv", row.names = FALSE) 
# summaries of  10050 runs.
#model_all_sum <- dout_all |> 
#  group_by(akey, modelf, typef, first_year, arun) |> 
#  summarise(count_years = length(ayear), 
#            count_years_unique = length(unique(ayear))) |> 
#  ungroup()
```

Compare lambda. Use this as the basis to establish number of runs to use.
```{r compare-lambda}
model_lookup <- readRDS("inst/other/model_lookup.rds")

model_lookup |> 
  mutate(recover_flag = if_else(fem_diff_t100 > 0, 1, 0)) |> 
  group_by(recover_flag) |> 
  summarise(model_count = n(),
            lambda_avg = mean(lambda_mean), 
            lambda_min = min(lambda_mean), 
            lambda_max = max(lambda_mean))
# 18 where mean lambda is less than one but population increases.
# 100, 144 and 198 with lowest lambda. Results uncertain
model_lookup |> 
  filter(fem_diff_t100 > 0, lambda_mean < 1) |> 
  arrange(lambda_mean)
# 10 where t100 females can be more or less than t0.
model_lookup |> 
  mutate(flag_uncertain = if_else((fem_q25_t100 < fem_t0) & (fem_q75_t100 > fem_t0), 
                                  1, 0)) |> 
  filter(flag_uncertain == 1) |> 
  arrange(lambda_mean)
```


Plots
```{r plot-lambda, eval=FALSE}
mean_values <- model_ref |> 
  group_by(typef) |> 
  summarise(mean_l = mean(lambda_mean))


fig_model_lambda <- model_ref |> 
  ggplot(aes(x = first_year, y = lambda_mean, colour = modelf)) + 
  geom_hline(data = mean_values, aes(yintercept = mean_l), 
             colour = "blue", linewidth = 0.8,
             linetype = "dashed") + 
  geom_hline(yintercept = 1, 
             colour = "magenta", linewidth = 0.8,
             linetype = "dashed") + 
  geom_point() + 
  stat_smooth(se = FALSE) + 
  scale_x_continuous("first year survival and graduation", 
                     breaks = c(0, 0.2, 0.4, 0.6, 0.8)) + 
  scale_color_viridis_d() +
  facet_wrap(~ typef, ncol = 6) + 
  theme(legend.position="top") + 
  guides(colour=guide_legend(nrow=2,byrow=TRUE)) + 
  labs(y = "lambda", colour = "model")
# save
png(file = "inst/other/fig_unifilis_lambda.png", bg = "transparent", 
    type = c("cairo"), 
    width = 9, height = 4, units = "in", res=600)
fig_model_lambda
invisible(dev.off())
             
```

Check plot.
```{r fig-lambda, echo = FALSE, fig.align = 'center', out.width = "70%", out.height = "70%", fig.cap="Model lambda for *Podocnemis unifilis*"}
knitr::include_graphics(path = "inst/other/fig_unifilis_lambda.png")
```


Projections over time.
```{r plot-projections, eval=FALSE}
fig_proj <- dout_all |> 
  ggplot(aes(x = ayear, y = fem, colour = modelf)) + 
  geom_point(size=0.1, alpha=0.2) + 
  stat_smooth(se = FALSE) + 
  scale_colour_viridis_d("model") + 
  scale_y_continuous(limits = c(0, (nf * 10))) +
  labs(y="Reproductive females",
       x="Time (years)",
       ) +
  theme_bw() +
  theme(plot.title.position = "plot") + 
  facet_grid(first_yearf ~ typef)

# save
png(file = "inst/other/fig_unifilis_projections.png", bg = "transparent", 
    type = c("cairo"), 
    width = 10, height = 8, units = "in", res=600)
fig_proj
invisible(dev.off())
           
```


Check plot.
```{r plot-models, echo = FALSE, fig.align = 'center', out.width = "70%", out.height = "70%", fig.cap="Model scenarios for *Podocnemis unifilis*"}
knitr::include_graphics(path = "inst/other/fig_unifilis_projections.png")
```

Number of adult females along 80 km2 of river.
```{r number-females}
# Here use density values from "tracaja_dist_5km_4z_beforeafter.R" to establish "impact"
# Adult population before - after
an_b4 <- ceiling((80 * 1.0035150)) # before = 81 in 80 km2 of river
an_b4_lci <- ceiling((80 * 0.38838535))
an_b4_uci <- ceiling((80 * 2.5928949))
an_aft <- ceiling((80 *  0.1542282)) # after  = 13 in 80 km2 of river
an_aft_lci <- ceiling((80 * 0.04021797))
an_aft_uci <- ceiling((80 * 0.5914359))
```


